/*
Auto-generated by: https://github.com/pmndrs/gltfjsx
Author: jlehman2028 (https://sketchfab.com/jlehman2028)
License: CC-BY-4.0 (http://creativecommons.org/licenses/by/4.0/)
Source: https://sketchfab.com/3d-models/rocket-ship-pixels-crumble-c030f75d753940a88cef037d00954183
Title: Rocket Ship Pixels crumble
*/

import React, { useEffect, useRef, useState } from 'react'
import { useGLTF } from '@react-three/drei'
import { useFrame } from '@react-three/fiber'

export function Rocket(props) {
  const { nodes, materials } = useGLTF('./models/rocket_ship_pixels_crumble.glb')
  const groupRef = useRef()
  const [animationProgress, setAnimationProgress] = useState(0)
  const [isAnimating, setIsAnimating] = useState(false)
  
  // Destructuring props z wartościami domyślnymi
  const {
    scale = 0.03,
    position = [1.3, -1, 0],
    rotation = [-Math.PI / 2, 2, 2],
    animationDuration = 2,
    startHeight = 90,
    ...otherProps
  } = props

  console.log('Rocket component rendering with position:', position)
  console.log('Nodes available:', Object.keys(nodes || {}))
  console.log('Materials available:', Object.keys(materials || {}))

  // Uruchom animację po załadowaniu komponentu
  useEffect(() => {
    console.log('Starting animation timer...')
    const timer = setTimeout(() => {
      console.log('Animation started!')
      setIsAnimating(true)
    }, 500) // Zwiększony delay
    return () => clearTimeout(timer)
  }, [])

  // Funkcja easing dla smooth animacji
  const easeOutCubic = (t) => 1 - Math.pow(1 - t, 3)

  // Animacja frame po frame
  useFrame((state, delta) => {
    if (groupRef.current) {
      const time = state.clock.getElapsedTime()
      
      // Animacja opadania
      if (isAnimating && animationProgress < 1) {
        const newProgress = Math.min(animationProgress + (delta / animationDuration), 1)
        setAnimationProgress(newProgress)
        
        const easedProgress = easeOutCubic(newProgress)
        const currentY = position[1] + startHeight - (startHeight * easedProgress)
        
        groupRef.current.position.set(position[0], currentY, position[2])
        console.log('Animating to position:', position[0], currentY, position[2])
        
        if (newProgress >= 1) {
          setIsAnimating(false)
          console.log('Animation completed!')
        }
      } else if (!isAnimating && animationProgress >= 1) {
        // Ustaw finalną pozycję i kołysanie
        const wobble = Math.sin(time * 2) * 0.5
        groupRef.current.position.set(position[0], position[1] + wobble, position[2])
        groupRef.current.rotation.z = rotation[2] + Math.sin(time * 2) * 0.02
      } else if (!isAnimating && animationProgress === 0) {
        // Pozycja startowa przed animacją
        groupRef.current.position.set(position[0], position[1] + startHeight, position[2])
        console.log('Set initial position:', position[0], position[1] + startHeight, position[2])
      }
    }
  })

  // Fallback jeśli model się nie załadował
  if (!nodes || !materials || !nodes.Object_9) {
    console.log('Model not loaded yet or missing nodes')
    return (
      <mesh ref={groupRef} position={position}>
        <boxGeometry args={[1, 2, 1]} />
        <meshStandardMaterial color="red" />
      </mesh>
    )
  }

  return (
    <group
      ref={groupRef}
      {...otherProps}
      dispose={null}
    >
      <group rotation={rotation}>
        <group scale={scale}>
          <group rotation={[-Math.PI / 2, Math.PI / 4, 0]}>
            <group>
              <mesh
                castShadow
                receiveShadow
                geometry={nodes.Object_9.geometry}
                material={materials.Material_28}
              />
              <mesh
                castShadow
                receiveShadow
                geometry={nodes.Object_11.geometry}
                material={materials.Material_27}
              />
              <mesh
                castShadow
                receiveShadow
                geometry={nodes.Object_13.geometry}
                material={materials.Material_29}
              />
              <mesh
                castShadow
                receiveShadow
                geometry={nodes.Object_15.geometry}
                material={materials.Material_42}
              />
              <mesh
                castShadow
                receiveShadow
                geometry={nodes.Object_17.geometry}
                material={materials.Material_30}
              />
            </group>
          </group>
        </group>
      </group>
    </group>
  )
}

useGLTF.preload('/models/rocket_ship_pixels_crumble.glb')